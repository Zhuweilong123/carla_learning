#   -*- coding: utf-8 -*-
# @Author  : Weilong Zhu
# @Time    : 2022-05-15,15:29
# @File    : Controller.py
"""
LQR 控制算法进行横向控制
总共分为5个模块
1 A,B计算模块
“
根据整车参数(a, b, Cf, Cr, m, Iz)和V_x,通过公式计算A,B; 具体公式间第八讲总结
a，b是前后轮中心距离车质心的距离
CF, Cr是前后轮的侧偏刚度
m是车的质量
Iz是车的转动惯量
V_x是车辆速度在车轴方向的分量
”
2 LQR 模块
“
根据Q,R和A,B计算K, 通过迭代黎卡提方程求解， P = Q + A^PA - A^PB(R+B^PB)'B^PA.其中A^是求转置，A'是求逆
代价函数：J = w1*X*X + w2*u*u,
当X和u都是列向量时，J= X^Qx + u^Ru，就是对所有误差进行求和
Q,R是误差代价和控制代价的权重对应的对角矩阵
”
3 e_rr, k计算模块
“
根据当前测量位置车辆的（x, y, fi, V_y, fi'）和规划位置的（x_r, y_r, theta_r, k_r）计算误差e_rr, 和投影点的曲率
由于车辆不具有路况的观察能力，且控制具有一定的滞后性，因此实际中需要加上一个预测模块，预测当前的车辆状态在到达下一个控制周期之前的可能位置
”
4 前馈控制模块计算delta_f
“
通过V_x, K, k和前馈控制公式计算前馈控制量delta_f
”
5 最终控制模块计算控制量u
“
通过u=-K*e_rr + delta_f计算最终控制量
”
"""
import numpy as np
import math
import carla
from planner_utiles import cal_heading_kappa, smooth_reference_line
from collections import deque


class Lateral_LQR_controller(object):
    def __init__(self, ego_vehicle, vehicle_para, pathway):
        self._vehicle_para = vehicle_para
        self._vehicle = ego_vehicle  # type: carla.Vehicle
        self._vehicle_state = None
        self._vehicle_Vx = 0
        self._target_path = []
        self.A = np.zeros(shape=(4, 4), dtype="float64")
        self.B = np.zeros(shape=(4, 1), dtype="float64")
        self.K = None
        self.k_r = None
        self.e_rr = None
        self.delta_f = None
        self.min_index = 0
        # debug 变量， 用于显示预测点和投影点的位置
        self.x_pre = 0
        self.y_pre = 0
        self.x_pro = 0
        self.y_pro = 0

        # 初始化
        self.waypoint_list_2_target_path(pathway)
        self.cal_vehicle_info()
        self.cal_A_B_fun()

    def waypoint_list_2_target_path(self, pathway):
        """
        将由路点构成的路径转化为（x, y, theta, k）的形式
        :param pathway: 【waypoint0, waypoint1, ...】
        :return: [(x0, y0, theta0, k0), ...]
        """
        w = None  # type: carla.Waypoint
        xy_list_ori = []
        for w in pathway:
            x = w[0].transform.location.x
            y = w[0].transform.location.y
            xy_list_ori.append((x, y))
        self._target_path = smooth_reference_line(xy_list_ori)  # 对生成的原始轨迹进行平滑

    def cal_vehicle_info(self):
        """
        通过调用方法获取车辆的状态信息
        :return: None
        """
        vehicle_loc = self._vehicle.get_location()
        x, y = vehicle_loc.x, vehicle_loc.y
        fi = self._vehicle.get_transform().rotation.yaw*(math.pi/180)  # 车身横摆角，车轴和x轴的夹角
        V = self._vehicle.get_velocity()  # 航向角是车速与x轴夹角
        V_length = math.sqrt(V.x*V.x + V.y*V.y + V.z*V.z)
        beta = math.atan2(V.y, V.x) - fi  # 质心侧偏角，车速和车轴之间的夹角
        # print("beta", beta, "fi", fi)
        Vy = V_length*math.sin(beta)  # 车速在车身坐标系下的分量
        Vx = V_length*math.cos(beta)
        # print("Vx", Vx, "Vy", Vy)
        fi_dao = self._vehicle.get_angular_velocity().z*(math.pi/180)
        self._vehicle_state = (x, y, fi, Vy, fi_dao)
        self._vehicle_Vx = Vx

    def cal_A_B_fun(self):
        """
        根据整车参数vehicle_para和V_x,通过公式计算A,B; 具体公式间第八讲总结
              vehicle_para: vehicle_para = (a, b, Cf, Cr, m, Iz)
                            a，b是前后轮中心距离车质心的距离
                            CF, Cr是前后轮的侧偏刚度
                            m是车的质量
                            Iz是车的转动惯量

              V_x: V_x是车辆速度在车轴方向的分量
        :return: 矩阵A和B, np.array type
        A的维度4*4
        B的维度4*1
        """
        V_x = self._vehicle_Vx
        V_x = V_x + 0.0001  # 因为速度有可能为零，加个小量，避免后面的除法运算报错
        (a, b, Cf, Cr, m, Iz) = self._vehicle_para

        self.A[0][1] = 1

        self.A[1][1] = (Cf + Cr) / (m * V_x)
        self.A[1][2] = -(Cf + Cr) / m
        self.A[1][3] = (a * Cf - b * Cr) / (m * V_x)

        self.A[2][3] = 1

        self.A[3][1] = (a * Cf - b * Cr) / (Iz * V_x)
        self.A[3][2] = -(a * Cf - b * Cr) / Iz
        self.A[3][3] = (a * a * Cf + b * b * Cr) / (Iz * V_x)

        self.B[1][0] = -Cf / m
        self.B[3][0] = -a * Cf / Iz

    def LQR_fun(self, Q, R):
        """
        根据Q,R和A,B计算K, 通过迭代黎卡提方程求解， P = Q + A^PA - A^PB(R+B^PB)'B^PA.其中A^是求转置，A'是求逆
        :param Q: 是误差代价的权重对应的对角矩阵4*4,Q越大算法的性能越好，但是会牺牲算法稳定性导致最终控制量u很大
        :param R: 控制代价的权重对应的对角矩阵4*4， R越大越平稳，变化越小
        :param A: cal_A_B_fun模块的输出4*4
        :param B:
        :return: K, np.array类型
        """
        P = Q
        P_pre = Q
        max_itr = 5000
        eps = 0.1
        ts = 0.1
        # 连续lqr离散化的时候， 系数矩阵相应发生变化
        A = np.matmul(np.linalg.inv(np.eye(4) - (ts*self.A)/2), (np.eye(4) + (ts*self.A)/2))
        B = ts*self.B
        i = 0
        AT = A.T  # 4*4
        BT = B.T  # 1*4
        for i in range(max_itr):
            P = AT @ P @ A - (AT @ P @ B) @ np.linalg.inv(R + BT @ P @ B) @ (BT @ P @ A) + Q  # 要不断迭代
            if abs(P - P_pre).max() < eps:
                break
            P_pre = P
        print(i)  # 输出迭代的次数

        self.K = np.linalg.inv(BT @ P @ B + R) @ (BT @ P @ A)

    def cal_error_k_fun(self, ts=0.1):
        """
        :param ts: 控制周期
        :param target_path: 规划路径构成的矩阵x, y是直角坐标系下位置， theta是速度方向与x轴夹角，k是路径在该点的曲率
        [(x1, y1, theta_1, k1),
         (x4, y3, theta_2, k2),
         ...]
        :param cur_state: 车辆当前位置(x, y, fi, V_x, V_y, fi')
        x,y是车辆测量得到的实际位置
        fi是航向角，车轴和x轴的夹角
        V_x, V_y是速度在车轴方向的分量和垂直车轴方向的分量
        fi'是fi的导数
        :return: 当前位置和目标位置在frenet坐标系下的横向误差e_rr，以及投影点的曲率k
        """
        x, y, fi, V_y, fi_dao = self._vehicle_state
        V_x = self._vehicle_Vx
        # 预测模块
        x = x + V_x * ts * math.cos(fi) - V_y * ts * math.sin(fi)
        y = y + V_y * ts * math.cos(fi) + V_x * ts * math.sin(fi)
        fi = fi + fi_dao * ts
        # V_x, V_y, fi_dao认为在相邻的周期内是不变的
        self.x_pre = x
        self.y_pre = y
        # 1.确定匹配点
        path_length = len(self._target_path)
        min_d = 10000

        for i in range(self.min_index, min(self.min_index + 50, path_length)):
            d = (self._target_path[i][0] - x) ** 2 + (self._target_path[i][1] - y) ** 2
            if d < min_d:
                min_d = d
                self.min_index = i
        min_index = self.min_index
        # print("min_index:", self.min_index)
        # 2.计算车身坐标系下的轴向向量和法向量
        tor_v = np.array([math.cos(self._target_path[min_index][2]), math.sin(self._target_path[min_index][2])])
        n_v = np.array([-math.sin(self._target_path[min_index][2]), math.cos(self._target_path[min_index][2])])

        # 3.计算匹配点指向实际位置的向量
        d_v = np.array([x - self._target_path[min_index][0], y - self._target_path[min_index][1]])

        # 4.计算e_d, e_s
        e_d = np.dot(n_v, d_v)
        e_s = np.dot(tor_v, d_v)

        # 获取投影点坐标
        self.x_pro, self.y_pro = np.array([self._target_path[min_index][0], self._target_path[min_index][1]]) + e_s * tor_v

        # 5.计算theta_r
        theta_r = self._target_path[min_index][2] + self._target_path[min_index][3] * e_s  # 认为投影点和匹配点航向不同，相差一个d_theta = k_r*d_s
        # theta_r = self._target_path[min_index][2]  # apollo方案， 认为投影点和匹配点的航向角相同

        # 6.计算e_d的导数
        e_d_dao = V_y * math.cos(fi - theta_r) + V_x * math.sin(fi - theta_r)

        # 7.计算e_fi
        e_fi = fi - theta_r
        # e_fi = math.sin(fi - theta_r)  # 这里为了防止角度的多值性，用sin(e_fi)近似e_fi， 一般情况下e_fi就是一个小量，所以可以近似

        # 8.计算S的导数
        S_dao = (V_x * math.cos(fi - theta_r) - V_y * math.sin(fi - theta_r)) / (1 - self._target_path[min_index][3] * e_d)

        # 9.计算e_fi的导数
        e_fi_dao = fi_dao - self._target_path[min_index][3] * S_dao

        # 10.计算投影点的曲率，近似等于匹配点的曲率
        self.k_r = self._target_path[min_index][3]
        self.e_rr = (e_d, e_d_dao, e_fi, e_fi_dao)
        print("error:", e_d, e_fi)

    def forward_control_fun(self):
        """
        计算前馈控制量delta_f
        :param vehicle_para: vehicle_para = (a, b, Cf, Cr, m, Iz)
        :param K: LQR的输出结果
        :param k_r: 投影点曲率
        :param V_x: 速度在车轴方向的分量
        :return: 前馈空盒子量delta_f
        """
        a, b, Cf, Cr, m, Iz = self._vehicle_para
        # print(self.K.shape)
        K_3 = self.K[0][2]
        V_x = self._vehicle_Vx
        self.delta_f = self.k_r * (a + b - b * K_3 - (b / Cf + a * K_3 / Cr - a / Cr) * (m * V_x * V_x) / (a + b))
        self.delta_f = self.delta_f*np.pi/180

    def LQR_control(self):
        """
        计算最终控制量
        :param K: LQR输出
        :param e_rr: 误差输出
        :param delta_f: 前馈输出
        :return: u最终控制量
        """
        b = 1
        Q = np.eye(4)
        Q[0][0] = 200
        Q[1][1] = 1
        Q[2][2] = 1
        Q[3][3] = 1
        R = b
        self.cal_vehicle_info()
        self.cal_A_B_fun()
        self.LQR_fun(Q=Q, R=R)
        self.cal_error_k_fun(ts=0.1)
        self.forward_control_fun()
        # print("**********", self.K)
        # print("**********", self.delta_f)
        # print("**********", self.k_r)
        current_steering = -np.dot(self.K, np.array(self.e_rr)) + self.delta_f
        current_steering = current_steering[0]
        return current_steering


class Longitudinal_PID_controller(object):
    """
    PID 控制
    包括比例项， 积分项，微分项
    只有比例项会产生稳态误差，（稳态误差就是控制最终稳定在一个值但是和目标值有一定的差距）
    引入积分项可以消除稳态误差，但是会引起超调、震荡问题和积分饱和问题
    采用积分分离来克服系统超调和震荡
    """
    def __init__(self, ego_vehicle,  K_P=1.15, K_I=0.75, K_D=0.35, dt=0.03):
        """
        采用PID进行纵向控制
        :param ego_vehicle: 控制的车辆， 类型是carla.Vehicle
        :param K_P: 比例项系数
        :param K_I: 积分项系数
        :param K_D: 微分项系数
        :param dt: 控制间隔
        """
        self._vehicle = ego_vehicle  # type: carla.Vehicle
        self.K_P = K_P
        self.K_I = K_I
        self.K_D = K_D
        self.dt = dt
        self.target_speed = None
        self.error_buffer = deque(maxlen=60)  # 设置一个误差缓存区，用于积分项和差分项的计算
        self.error_threshold = 1  # 设定一个阈值，进行积分分离，标量单位是km/h,
        # 由于carla的最大throttle是1，因此误差如果大于1就让采取积分分离

    def PID_fun(self):
        """

        :return:
        """
        cur_velocity = self._vehicle.get_velocity()  # 调用carla API 获得的速度是个三维矢量 单位是m/s
        cur_speed = 3.6*math.sqrt(cur_velocity.x*cur_velocity.x
                                  + cur_velocity.y*cur_velocity.y
                                  + cur_velocity.z*cur_velocity.z)  # 转化为标量，单位是km/h

        error = self.target_speed - cur_speed  # 当前误差
        self.error_buffer.append(error)  # 将新的误差放入缓存区，如果缓存区满了，最左边的溢出，整体数据左移一位，新的数据加在最右边

        if len(self.error_buffer) >= 2:
            # 积分误差
            integral_error = sum(self.error_buffer) * self.dt
            # 微分误差
            differential_error = (self.error_buffer[-1] - self.error_buffer[-2]) / self.dt
        else:
            integral_error = 0.0
            differential_error = 0.0

        # 积分分离
        print("absolute error:", abs(error))
        if abs(error) > self.error_threshold:
            # 一旦出现误差大于阈值的情况，积分分离让积分项为0，清除误差缓存区，此时只有比例项发挥作用
            integral_error = 0.0
            self.error_buffer.clear()

        return self.K_P * error + self.K_I * integral_error + self.K_D * differential_error

    def PID_control(self, target_speed):

        self.target_speed = target_speed
        return self.PID_fun()


class Vehicle_control(object):
    def __init__(self, ego_vehicle, vehicle_para, pathway):
        self._vehicle = ego_vehicle
        self._max_throttle = 1
        self._max_brake = 1
        self._max_steer = 1
        self.min_steer = -1

        self.Lat_control = Lateral_LQR_controller(ego_vehicle, vehicle_para, pathway)
        self.Lon_control = Longitudinal_PID_controller(ego_vehicle)  # 这里不允许后续程序修改PID的参数，使用设定好的默认值

    def run_step(self, target_speed):

        control = carla.VehicleControl()
        control.hand_brake = False
        control.manual_gear_shift = False
        control.gear = 1
        current_steering = self.Lat_control.LQR_control()
        # 获取横向和纵向控制量
        current_acceleration = self.Lon_control.PID_control(target_speed)

        # 横向控制整定
        # past_steering = self._vehicle.get_control().steer
        # #
        # if current_steering > past_steering + 0.1:
        #     current_steering = past_steering + 0.1
        # elif current_steering < past_steering - 0.1:
        #     current_steering = past_steering - 0.1
        if current_steering >= 0:
            steering = min(self._max_steer, current_steering)
        else:
            steering = max(self.min_steer, current_steering)
        # steering = current_steering
        control.steer = steering

        # 纵向控制整定
        if current_acceleration >= 0:
            control.throttle = min(self._max_throttle, current_acceleration)
            control.brake = 0
        else:
            control.throttle = 0
            control.brake = max(self._max_brake, current_acceleration)  # 没有反向加速，加速度为零时对应的是刹车制动

        V = self._vehicle.get_velocity()
        V_len = 3.6*math.sqrt(V.x * V.x + V.y * V.y + V.z * V.z)

        print("current speed:", V_len, "current steer:", steering)
        return control
